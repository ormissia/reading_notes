---
doc_type: weread-highlights-reviews
bookId: "729216"
reviewCount: 0
noteCount: 18
author: 林沛满
cover: https://wfqqreader-1252317822.image.myqcloud.com/cover/216/729216/t7_729216.jpg
readingStatus: 读完
progress: 89%
totalReadDay: 5
readingTime: 6小时53分钟
readingDate: 2024-03-20
finishedDate: 2024-04-15
isbn: 9787115366610
category: 计算机 计算机综合
title: Wireshark网络分析就这么简单
rating: 87.6%
readProgress: 100
readingTimestamp: 24839
lastReadDate: 2024-04-15
lastReadTimestamp: 1713160091
tags: 读书笔记 计算机 计算机综合 读完
totalWords: 89611

---

# Wireshark网络分析就这么简单

# 元数据
> [!abstract] Wireshark网络分析就这么简单
> - ![ Wireshark网络分析就这么简单|200](https://wfqqreader-1252317822.image.myqcloud.com/cover/216/729216/t7_729216.jpg)
> - 书名： Wireshark网络分析就这么简单
> - 作者： 林沛满
> - 简介： 　　Wireshark可能是世界上最好的开源网络包分析器，能在多种平台上(比如Windows、Linux和Mac)抓取和分析网络包，在IT业界有着广泛的应用。　　《Wireshark网络分析就这么简单》采用诙谐风趣的手法，由浅入深地用Wireshark分析了常见的网络协议，读者在学习Wireshark的同时，也会在不知不觉中理解这些协议。作者还通过身边发生的一些真实案例，分享了Wireshark的实战技巧。　　《Wireshark网络分析就这么简单》不务虚，不注水，几乎页页干货，篇篇精华，力求为读者提供最佳阅读体验，使读者在一个轻松愉悦的阅读氛围中，潜移默化地掌握Wireshark的使用技巧和网络知识，为你的工程师生涯加油助力。　　无论你是技术支持工程师、系统管理员、现场工程师、公司IT部门的老好人，还是高校网络相关专业的教师，无论你是CCNA、CCNP、CCIE，还是MCSE，《Wireshark网络分析就这么简单》都是迅速了解、掌握Wireshark技巧的绝佳读物。
> - 出版时间 2014-12-01 00:00:00
> - ISBN： 9787115366610
> - 分类： 计算机-计算机综合
> - 出版社： 人民邮电出版社



---

# 高亮划线

## 初试锋芒

> [!Cite]+ <span style="color: #ffce78;">Highlight</span>
> 📌 我每次当面试官，都要伪装成无所不知的大牛。
> ^7-465-486

> [!Cite]+ <span style="color: #ffce78;">Highlight</span>
> 📌 一下子把气氛从学术殿堂拉到建筑工地。不过就是这些最基础的问题，却常常把简历精英们难住。
> ^7-669-712
### TCP的连接启蒙

> [!Cite]+ <span style="color: #ffce78;">Highlight</span>
> 📌 一个Seq号的大小是根据上一个数据段的Seq号和长度相加而来的。
> ^15-3334-3366

> [!Cite]+ <span style="color: #ffce78;">Highlight</span>
> 📌 你也许想问51号包为什么没有对应的确认包呢？其实53号包确认6577的时候，表示序号小于6577的所有字节都收到了，相当于把51号发送的字节也一并确认了，也就是说TCP的确认是可以累积的。
> ^15-4357-4451

> [!Cite]+ <span style="color: #ffce78;">Highlight</span>
> 📌 SYN：携带这个标志的包表示正在发起连接请求。因为连接是双向的，所以建立连接时，双方都要发一个SYN。
> ^15-5558-5609

> [!Cite]+ <span style="color: #ffce78;">Highlight</span>
> 📌 FIN：携带这个标志的包表示正在请求终止连接。因为连接是双向的，所以彻底关闭一个连接时，双方都要发一个FIN。
> ^15-5640-5695

> [!Cite]+ <span style="color: #ffce78;">Highlight</span>
> 📌 事实上，握手时Seq号并不是从0开始的。我们之所以在Wireshark上看到Seq=0，是因为Wireshark启用了RelativeSequenceNumber。如果你想关闭这个功能，可以在Edit-->Preferences-->protocols-->TCP里设置。
> ^15-6525-6669
### 快递员的工作策略—TCP窗口

> [!Cite]+ <span style="color: #ffce78;">Highlight</span>
> 📌 但现实中也存在一些限制：接收方的缓存（接收窗口）可能一下子接受不了这么多数据；网络的带宽也不一定足够大，一口气发太多会导致丢包事故。所以，发送方要知道接收方的接收窗口和网络这两个限制因素中哪一个更严格，然后在其限制范围内尽可能多发包。这个一口气能发送的数据量就是传说中的TCP发送窗口。
> ^16-950-1093

> [!Cite]+ <span style="color: #ffce78;">Highlight</span>
> 📌 当发送窗口是由接收窗口决定的时候，我们还可以通过“windowsize:”的值来判断。而当它由网络因素决定的时候，事情就会变得非常复杂（下篇文章将会详细介绍）。大多数时候，我们甚至不确定哪个因素在起作用，只能大概推理。
> ^16-4181-4291

> [!Cite]+ <span style="color: #ffce78;">Highlight</span>
> 📌 发送窗口决定了一口气能发多少字节，而MSS决定了这些字节要分多少个包发完。
> ^16-4616-4653

> [!Cite]+ <span style="color: #ffce78;">Highlight</span>
> 📌 确认包一般会少一些。由于TCP可以累积起来确认，所以当收到多个包的时候，只需要确认最后一个就可以了。
> ^16-4843-4893
### 重传的讲究

> [!Cite]+ <span style="color: #ffce78;">Highlight</span>
> 📌 网络之所以能限制发送窗口，是因为它一口气收到太多数据时就会拥塞。拥塞的结果是丢包，这是发送方最忌惮的。能导致网络拥塞的数据量称为拥塞点，发送方当然希望把发送窗口控制在拥塞点以下，这样就能避免拥塞了。但问题是连网络设备都不知道自己的拥塞点，即便知道了也无法通知发送方。
> ^17-661-794

> [!Cite]+ <span style="color: #ffce78;">Highlight</span>
> 📌 下面我们就来看看拥塞窗口如何维护。
>
>1.连接刚刚建立的时候，发送方对网络状况一无所知。如果一口气发太多数据就可能遭遇拥塞，所以发送方把拥塞窗口的初始值定得很小。RFC的建议是2个、3个或者4个MSS，具体视MSS的大小而定。
>
>2.如果发出去的包都得到确认，表明还没有达到拥塞点，可以增大拥塞窗口。由于这个阶段发生拥塞的概率很低，所以增速应该快一些。RFC建议的算法是每收到n个确认，可以把拥塞窗口增加n个MSS。比如发了2个包之后收到2个确认，拥塞窗口就增大到2+2=4，接下来是4+4=8,8+8=16……这个过程的增速很快，但是由于基数低，传输速度还是比较慢的，所以被称为慢启动过程。
>
>3.慢启动过程持续一段时间后，拥塞窗口达到一个较大的值。这时候传输速度比较快，触碰拥塞点的概率也大了，所以不能继续采用翻倍的慢启动算法，而是要缓慢一点。RFC建议的算法是在每个往返时间增加1个MSS。比如发了16个MSS之后全部被确认了，拥塞窗口就增加到16+1=17个MSS，再接下去是17+1=18,18+1=19……这个过程称为拥塞避免。从慢启动过渡到拥塞避免的临界窗口值很有讲究。如果之前发生过拥塞，就把该拥塞点作为参考依据。如果从来没有拥塞过就可以取相对较大的值，比如和最大接收窗口相等。
> ^17-1417-2054

> [!Cite]+ <span style="color: #ffce78;">Highlight</span>
> 📌 从发出原始包到重传该包的这段时间称为RTO。RTO的取值颇有讲究，理论上需要几个公式计算出来。
> ^17-2961-3008

> [!Cite]+ <span style="color: #ffce78;">Highlight</span>
> 📌 重传之后的拥塞窗口是否需要调整呢？非常有必要，为了不给刚发生拥塞的网络雪上加霜，RFC建议把拥塞窗口降到1个MSS，然后再次进入慢启动过程。
> ^17-3338-3408

> [!Cite]+ <span style="color: #ffce78;">Highlight</span>
> 📌 超时重传对传输性能有严重影响。原因之一是在RTO阶段不能传数据，相当于浪费了一段时间；原因之二是拥塞窗口的急剧减小，相当于接下来传得慢多了。
> ^17-4040-4110

> [!Cite]+ <span style="color: #ffce78;">Highlight</span>
> 📌 ·没有拥塞时，发送窗口越大，性能越好。所以在带宽没有限制的条件下，应该尽量增大接收窗口，比如启用ScaleOption（Windows上可参考KB224829）。
>
>·如果经常发生拥塞，那限制发送窗口反而能提高性能，因为即便万分之一的重传对性能的影响都很大。在很多操作系统上可以通过限制接收窗口的方法来减小发送窗口，Windows上同样可以参考KB224829。
>
>·超时重传对性能影响最大，因为它有一段时间（RTO）没有传输任何数据，而且拥塞窗口会被设成1个MSS，所以要尽量避免超时重传。
>
>·快速重传对性能影响小一些，因为它没有等待时间，而且拥塞窗口减小的幅度没那么大。
>
>·SACK和NewReno有利于提高重传效率，提高传输性能。
>
>·丢包对极小文件的影响比大文件严重。因为读写一个小文件需要的包数很少，所以丢包时往往凑不满3个DupAck，只能等待超时重传了。而大文件有较大可能触发快速重传。
> ^17-8127-8678
### 延迟确认与Nagle算法

> [!Cite]+ <span style="color: #ffce78;">Highlight</span>
> 📌 和延迟确认一样，Nagle也没有直接提高性能，启用它的作用只是提高传输效率，减轻网络负担。
> ^18-2951-2997

